


### SNS_SQS

- 스프링 애플리케이션과 AWS 서비스인 SNS, SQS를 이용하여 이벤트 기반 아키텍처를 구현하고 있다.


#### 스프링 애플리케이션, SNS, SQS를 이용하여 이벤트 기반 아키텍처 구조

- 위 그림을 통해서 확인할 수 있듯이 유저의 요청에 따라서 이벤트를 발행하고 수신하게 된다.
  1. 유저가 유저 인터페이스(API)를 통해서 애플리케이션에게 요청을 하면 해당 애플리케이션은 기능을 수행한다.
  2. 애플리케이션이 기능을 수행하는 도중 SNS에게 이벤트를 발행한다.
  3. SNS는 구독중인 SQS에게 메시지를 전송한다.
  4. SQS에 존재하는 메시지를 애플리케이션이 소비하여 해당 이벤트에 대한 기능들을 수행한다.
- 해당 기능들이 우리가 원하는 대로 작동만한다면 좋겠지만, 네트워크 또는 비지니스 로직의 문제로 인하여 메시지가 제대로 송수신이 안되는 경우가 발생할 수 있다.
  - 이벤트 기반 아키텍처를 사용하게되면 해당 기능의 흐름을 정확히 파악하기 어려운 문제가 발생한다.
  - 때문에 문제가 발생하였을 때 실패한 메시지를 제대로 보관하고 있지 않다거나, 해당 문제가 발생하였을 때 자동화를 하지 않거나, 모니터링을 수행하지 않게되면 개발자가 문제를 해결할 수 없거나 유저 입장에서도 서비스를 제대로 사용할 수 없다.
- 때문에 단순히 기능을 만드는 것 뿐만 아니라 운영시 발생할 수 있는 이슈들에 대하여 대비를 할 수 있어야 한다.


#### 스프링 애플리케이션, SNS, SQS를 이용하여 이벤트 기반 아키텍처 운영시 발생할 수 있는 문제

- 스프링 애플리케이션, SNS, SQS를 통해서 이벤트 기반 아키텍처를 구현할 때 발생할 수 있는 주요
  - SQS에서 애플리케이션에 전송시 발생할 수 있는 문제
  - SNS에서 SQS에게 메시지를 전송시 발생할 수 있는 문제
  - 애플리케이션에서 SNS를 전송시 발생할 수 있는 문제
- 애플리케이션-SNS-SQS-애플리케이션으 흐름이 이어지는 상황에서 우리가 사용자에게 메시지를 어떻게 자동으로 다시 재전송할 수 있을지에 대하여 고민을 해봐야 한다.

#### 1. SQS에서 애플리케이션에 전송시 발생할 수 있는 문제
- SQS를 통해서 애플리케이션이 해당 메시지를 소비하는 과정에 문제가 발생할 수 있다.
- 이를 해결하기 위하여 두 가지 단계를 통해서 문제를 해결한다.
  - 메시지 소비가 실패할 경우 해당 메시지를 DLQ로 이동
  - DLQ의 메시지는 수동으로 리드라이브 하는 것이 아닌 자동으로 리드라이브할 수 있도록 설정
- SNS에서 DLQ로 이동을 하는 상황을 먼저 만들어서 해당 DLQ를 자동으로 리드라이브 할 수 있도록 제작예정
- SNS에서 DLQ로 메시지가 이동할 때 중요한 것은 ***Visibility Timeout (표시 제한 시간), DLQ 최대 수신 수 ***이다.

- SQS는 대기열에 존재하는 메시지를 정상적으로 수신하지 못한 경우 해당 메시지를 DLQ로 이동할 수 있다.
  - 메시지가 DLQ로 이동하게 되면서 해당 메시지를 분석하여 애플리케이션의 문제를 파악할 수 있으며, 해당 문제가 해결된 이후에 다시 DLQ에 존재하는 메시지를 SQS로 옮겨 재전송 할 수 있다.
- SQS가 DLQ로 이동하는 원리를 알기 위해서는 ***표시 제한 시간, DLQ 최대 수신 수***에 대해서 알고 있으면 좋다.
  - 해당 내용을 자세히 알고 싶으면 [SQS](https://github.com/yhnoh/aws/tree/master/sqs) 자료를 참고하자.

1. SQS 메시지 수신 실패시 DLQ로 메시지 이동 
![](./img/sqs_dlq_setting.png)
- `HELLO, HELLO_DLQ` 두개의 큐를 생성한 이후, HELLO 큐에 HELLO_DLQ를 셋팅해 두었다.
- 표시제한시간은 30초 이기 때문에 메시지가 정상적으로 처리되지 않을 경우 30초 뒤에 재 수신을 한다.
- DLQ 최대 수신수는 1이기 때문에 1번 수신을 실패하게 되면 DLQ로 메시지가 이동하게 된다.

```java
@RestController
@RequiredArgsConstructor
public class HelloController {

    private final SqsTemplate sqsTemplate;
    private static final String QUEUE_NAME = "HELLO";

    @GetMapping("/hello-world")
    public String helloWorld() {
        SendResult<String> result = sqsTemplate.send(to -> to.queue(QUEUE_NAME).payload("hello world"));
        return result.message().getPayload();
    }

    @SqsListener(QUEUE_NAME)
    public void receiveMessage(@Headers Map<String, String> headers, @Payload String payload) {
        System.out.println("메시지 수신 성공!!!");
        throw new IllegalArgumentException("비지니스 로직 문제 발생");
    }

}
```
- 해당 소스를 확인하게 되면 `/hello-wrold`엔드포인트를 호출하게 되면 `HELLO`에 메시지를 전송하게 된다.
- 이후 `HELLO` 큐에 담긴 메시지를 소비하는데 이때 메시지를 정상적으로 수신하지 못하도록 Exception을 발생시킨다.
- 해당 엔드포인트를 호출한 이후에 DLQ로 메시지가 이동하는지 한번 확인해보자.
<br/>

![](./img/sqs_dlq_check.png)

- DLQ에 정상적으로 메시지가 이동된것을 확인할 수 있으며, 해당 메시지를 리드라이브 하기전에 메시지를 분석하여 애플리케이션에 어떤 문제가 있는지 진단할 수 있게 되었다.
- 애플리케이션에서 발생한 문제의 경우 해당 애플리케이션을 수정한 이후 배포를 진행하고 수동으로 DLQ에 존재하는 메시지를 리드라이브하면 정상적으로 메시지를 소비할 수 있게된다.
- 하지만 수동으로 콘솔 또는 SQS API를 통해서 메시지 리드라이브를 한다는 것은 좋은 방법이 아니기 때문에 이를 자동으로 전환해줄 필요성이 있다.

2. DLQ로 이동한 메시지를 자동으로 리드라이브하기
- 자동으로 리드라이브를 하기위해서는 두가지 조건이 필요하다.
  - Amazon SQS에서 리드라이브관련 API를 제공하는지?
  - 스케쥴러 또는 특정 트리거를 통해서 리드라이브 API를 호출할 수 있는지?
- Amazon SQS에서는 리드라이브 관련 API를 제공하고 있으며, 특정 트리거가 아닌 배치 시스템을 통해서 해당 문제를 해결한다.
  - 배치를 이용하는 이유는 


- 메시지 소비가 실패할 경우 해당 메시지를 DLQ로 이동, 이동된 DLQ의 메시지는 수동으로 리드라이브 하는 것이 아닌 자동으로 리드라이브 할 수 있도록 작업 진행
1. SNS에서 SQS에게 메시지를 전송시 발생할 수 있는 문제
2. 애플리케이션에서 SNS를 전송시 발생할 수 있는 문제


> https://techblog.woowahan.com/7835/