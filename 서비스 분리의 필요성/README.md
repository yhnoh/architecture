### 1. 서비스란?
---

- 비지니스 로직을 수행하는 역할을 하며 애플리케이션 내부에서 수행해야하는 거의 모든 작업을 의미한다.
> 비지니스 로직을 단순히 CRUD의 의미로 받아들이면 안되고, 회원가입, 회원 정보 조회와 같은 사용자의 하나의 행위를 담아낸 로직이라고 이해하는 것이 좋다. <br/>
> 때문에 단순 CURD보다 특정 상황에 맞는 더 복잡한 로직들을 구현해야하는 경우가 많다. <br/>
> 이렇게 해야 사용자 행위와 비슷한 네이밍이 클래스 정보에 담길 수 있다.

 

### 2. 서비스의 역할
---

1. 애플리케이션 내부 사용자가 필요한 데이터를 리턴 ex) DTO, Domain… (출력을 반환)
   - 외부에게 노출되는 데이터가 아니므로 오해해서는 안된다. ex) Response
   - 때문에 외부에게 필요한 데이터를 응답하기 위해서는 따로 매핑을 진행해야한다. (논의 필요)
2. 데이터를 조회, 삽입, 수정, 삭제를 진행하기 위해서 필요한 모든 행위를 진행한다.
   - 해당 행위는 비지니스 로직을 위한 행위여야 한다.
3. 입력 모델에 대한 유효성 검사
   - 해당 행위는 서비스 내에서 진행할 수 있고 입력 모델 내에서도 진행할 수 있다.
4. 비지니스 로직에 대한 유효성 검사
   - 비지니스 로직에 대한 유효성 검사는 서비스 내에서 진행하는 것이 좋다.

 

### 3. 서비스 분리의 필요성
---

- 서비스를 분리하지 않을 경우 어떤 일이 발생하는지 알아보자.

#### 3.1. 하나의 서비스에 많은 코드가 생성된다.
- 하나의 서비스에 많은 코드가 생성된다.

```java
@Service
@RequiredArgsConstructor
public class MemberService{
    private final MemberRepository memberRepository;

    //회원 가입
    public void join(Member member){
    //...
    }

    //회원 탈퇴
    public void deleteMember(String memberId){
    //...
    }

    //회원 수정
    public void modifyMember(ModifyMember member){
    //...
    }

    //조회 메서드....    
}
```
- 하나의 서비스에 많은 내용이 담겨짐으로 인해서 사용하는 입장에서 어떤걸 사용해야하는지 알 수 없다.
- 코드양이 많아 지기 때문에 해당 로직을 파악하기가 힘들어진다.
  - 파악이 힘들어진다는 것은 수정자체가 어려워진다.
- 다른 개발자가 회원 관련 추가 기능을 만들 때, MemberService 에 지속적으로 코드를 추가할 확률이 높다.
  - https://namu.wiki/w/깨진 유리창 이론

#### 3.2. 서비스가 분리되어 있지 않으면 불필요한 의존성이 많아진다.

- 객체지향언어에서는 응집도를 높이라는 말이 있다.
  - 응집도란 하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관도를 이야기한다.
  - 때문에 응집도가 낮으면 이해하기 힘들고, 유지보수하기 힘든 코드가 된다.
- 클래스레벨로 넘어가서 모듈을 클래스, 기능을 클래스의 메서드라고 먼저 생각해보고 아래의 코드를 보자.

```java
public class ABCD {

    private int a;
    private int b;
    private int c;
    private int d;

    public int ab() {
        return a + b;
    }

    public int cd() {
        return c + d;
    }
}
```
  - `ab()` 메서드는 `int a, int b`의 변수만 활용하고 있고, `cd()` 메서드는 `int c, int d` 변수만 활용하고 있다.
  - 위와 같은 코드가 바로 응집도가 낮은 클래스이다.
  - 응집도를 높이기 위해서는 아래와 같이 필요한 변수만 사용하는 메서드를 사용하도록 클래스를 분리해야한다.
```java
public class AB {

    private int a;
    private int b;

    public int ab() {
        return a + b;
    }
}

public class CD {
    private int c;
    private int d;
    public int cd() {
        return c + d;
    }

}
```
- `MemberService`라는 하나의 서비스에서 불필요한 의존성을 많이 추가할 수록 코드를 이해하기 힘들고, 유지보수가 힘든 코드가 된다.
- 때문에 기능별 또는 팀간의 회의를 통해서 서비스를 분리해야한다.

> 도메인 주도 설계 철저 입문, 나루세 마사노부, p133-141

#### 3.3. 서비스가 분리되어있지 않아 테스크 코드 작성이 어려워진다.

- 하나의 서비스에 기능에 대한 모든 코드가 담겨져 있다면 유닛 테스트 코드 작성 자체가 어려워진다.
- 또한 불필요한 의존성이 많아 어떤 의존성을 Mock으로 만들어 테스트해야할지 헷갈리기 시작한다.
- 만약 Mock으로 만들어서 테스트를 진행한다 하여도 테스트 코드 내에서 어떤걸 목적으로 테스트하는지 불분명하다.
- 뿐만아니라 프로덕션 코드의 패키지 및 이름을 따와서 테스트를 작성하기 때문에 테스토 코드 자체 내에서도 코드양이 많아진다.
  - 후에 해당 테스트 코드가 무엇인지 파악하기가 힘들다.
> 테스트 코드 작성자체가 어렵다는 말은 해당 서비스의 구조 자체가 잘못되었다는 의미이기도 하다. 
- 위와 같은 이유로 인해서 테스트 코드를 작성하기 힘들어지면 누군가는 해당 테스트 코드를 작성하지 않는 경우가 발생할 수 있다.
  - 왜냐하면 테스트코드는 강제성이 없기 때문이다.
  - 이는 즉, 변경에 취약한 서비스가 만들어지기 쉽다.



### 4. 어떤 식으로 서비스를 분리할 것인가?
---

#### 4.1. 조회서비스를 분리하자.

#### 4.2. 매핑 서비스를 만들자.

#### 4.3. 수정, 삭제, 삽입을 각 클래스 별로 만들자.

#### 4.4. 저장소의 역할을 명확히 분리하자.




