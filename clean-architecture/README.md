

### 1. 계층형 아키텍처 (Layerd Architecture)

---

#### 1.1 계층형 아키텍처 구조

![](./img/layerd_architecture.png)

- 우리가 흔히 개발하는 방식들은 계층형 아키텍처로 위와 같은 흐름을 가지고 있다.
  
1. Database Layer, Persistence Layer
  - 저장소에서 데이터를 불러와 dao(jpa entity)에 매핑한다.
    - 저장소는 Database라고 이해하지 말고 `데이터를 저장하는 곳`이라고 이해하면 좋다.
    - 때문에 저장소는 Database, File, 외부 API 등이 될 수 있다.
  - 저장소와 연결되어 저장소의 데이터를 처리하는 layer다.
    - 주로 CRUD 작업을 실제로 처리하는 정보들을 가지고있다.
2. Domain or Business or Service Layer
  - dao를 가지고와 실제 비지니스 로직을 수행하는 역할을 하며 애플리케이션 내부에서 수행해야하는 거의 모든 작업들을 진행한다.
    - 애플리케이션 내부 사용자가 필요한 데이터를 리턴 (DTO)
    - 저장소에 데이터를 삽입, 수정, 삭제를 진행하기 위해서 필요한 행위를 진행
    - 입력 모델에 대한 유효성 검사
    - 비지니스 로직에 대한 유효성 검사  
    - 등등..
3. Presentation Layer
  - 애플리케이션 외부의 사용자와의 상호작용을 처리하는 계층이다.
    - 외부 사용자가 요청 수 있는 방법을 제공
      - HTTP, TCP, CLI 
    - 외부 사용자에게 요청을 어떻게 받을지 어떻게 응답을 할지 결정
      - JSON, HTML, XML 
    - 외부 사용자 요청에 대한 입력 모델을 검사



#### 1.2. 계층형 아키텍쳐 패키지 구조
- 모든 것을 일반화 하기는 힘들 겠지만 계층형 아키텍처의 패키지 구조는 기능별 또는 화면별로 패키지를 먼저 구분하고 아래와 같은 구조를 가질 것이다.
```text
└── member
    ├── controller
    │   └── MemberController.java
    ├── dto
    │   └── MemberDTO.java
    ├── entity
    │   └── MemberJpaEntity.java
    ├── repository
    │   └── MemberJpaRepository.java
    └── service
        ├── MemberService.java
        └── MemberServiceImpl.java
```
- controller 패키지는 Presentation Layer로써 사용자의 요청과 응답을 처리한다.
- service 패키지는 Domain or Business or Service Layer 로써 member와 관련된 모든 비지니스 로직을 담당한다.
  - service는 repository와 관련된 의존성을 가지고 있으며 dao 가져와서 비지니스 로직을 처리한다.
  - service와 service, service와 controller는 dto를 통해서 데이터를 주고 받는다.
- repositroy는 저장소에 데이터를 불러와 dao에 매핑을 한다.

#### 1.3. 계층형 아키텍쳐에 대해 생각해보기

1. 계층형 아키텍쳐를 사용하면 관심사를 분리하여 각 계층별로 무엇을 해야할지가 명확하다.
2. 관련된 내용을 서로 모아놓기 때문에 응집도가 높고, 기본적으로 인터페이스를 두고 개발을 진행하기 때문에 결합도가 낮은 특징을 가지고 있다.
  - 때문에 한눈에 알아보기 쉽고 쉽게 변경가능하다.

#### 1.4. 계층형 아키텍쳐는 무엇이 문제일까?

> Domain or Business or Service Layer를 서비스 계층 또는 서비스라고 임의로 말하겠다. 

1. 프로젝트가 커지면서 서비스 계층의 역할이 많다보니 작업하는 서비스가 어떤 역할인지 알아보기가 힘들어진다.
   - 예를 들어 MemberSerivce라는 클래스 파일명을 보면 이 클래스가 무슨 역할을 하는지 알 수 있는가?
     - 정확히 해당 서비스가 어떤 역할을 하는지 파악하기 힘들기 때문에 MemberService로 들어가서 우라가 필요로하는 메서드들을 찾고 잇을 것이다.
   - ***새로운 개발보다 서비스 로직을 파악하는데 더욱 많은 시간을 쓰는일이 발생***한다.

2. 여러 개발자와 협업시 서비스내의 코드가 무분별하게 작성된다.
   - MemberService를 기준으로 예를 한번 들어보자.
     - 한 개발자가 Member에 대한 비지니스 로직을 처리한다고 생각해보면 해당 개발자는 자연스럽게 MemberService에 필요한 작업을 진행하고 있을 것이다.
     - 계속해서 다른 개발자가 Member에 대한 비지니스 로직을 만들기 위해서 MemberSerivce에서 작업을 진행한다.
     - Member에 대한 기능이 늘어날 수록 MemberService의 코드 양은 어마어마 하게 늘어나게 될 것이다.
   - ***서비스 클래스의 코드양이 많아지면 새로운 기능을 작성하거나 수정하는 입장에서 서비스의 내용을 파악하기 위해서 많은 시간을 쓰게 될 것***이다.
     - 특히 새로운 개발자가 들어오게 되면 이게뭐지? 라는 생각을 가지게 된다.
   - MemberSerivce의 코드양이 많아진다는 의미는 ***의존성도 끊임없이 늘어날 수 있다는 의미이므로 테스트 코드 작성이 쉽지 않을 것***이다.
   - MemberSerivce내에 ***기능이 많아지다 보니*** MemberService를 ***사용하는 입장에서도 어떤 메서드를 사용해야할지 파악하기 힘들 수 있다.***
   - Serive의 코드양이 계속 많아지는 상황을 해결하기 위해서 서비스를 회원별 기능으로 나누어 작업하는 진행하기도 한다.
     - 당장의 문제를 현실적으로 해결하기위한 좋은 방법이라고 생각한다.
   
3. 기껏 만들고 있는 서비스 인터페이스가 의미가 없어진다.
   - 서비스 인터페이스를 구현한 서비스 구현 클래스는 필수적으로 만들 수 밖에 없다.
   - 인터페이스를 만드는 이유는 실제 구현 클래스가 무슨일을 하는지 숨기고 싶거나 무엇을 표현하고자 할때 쓰인다.
   - MemberSerivce의 경우 MemberServiceImpl이외에 다른 클래스에서 사용되고 있지 않다.
     - 무슨일을 숨기기 위해서 사용되는 것도 아니라면 무엇을 표현하고자할 때 쓰여야하는데 MemberService라는 것을 보고 과연 다른 개발자들이 이게 무엇을 의미하는지 알 수 있을까?
   - 왜 만들어야 되는지에 대한 고민 없이 그냥 그렇게 만들어왔으니까 만드는 경우를 나는 많이 목격해왔다.

4. 서비스 계층에서 Data Access Object를 직접 접근하기 때문에 변경하기 힘든 코드가 된다.
  - Data Access Object 를 직접 다룬다는 말은 아래와 같은 코드를 의미한다.
    ```java
    @Service
    @RequiredArgsConstructor
    public class MemberServiceImpl implements MemberService {
        
        private final MemberJpaRepository memberJpaRepository;
        
        public void join(MemberDTO memberDTO){

            //DAO에 직접 접근하여 저장까지 진행
            Member member = new Member(memberDTO.getUsername());
            memberJpaRepository.save(member);
        }
    }
    ```
  - 요즘은 JPA를 많이 쓰고 있기 때문에 JPA를 기준으로 코드를 작성해 보았다.
  - 서비스 코드가 JPA의 기능을 직접 제어하고 있기 때문에 ***엔티티가 변경이 되었을 때 변경된 서비스 코드를 전부 봐야하는 경우가 발생***한다.
    - 소규모 프로젝트의 경우는 그래도 작업이 가능하지만 대규모 프로젝트의 경우에는 모든 서비스 코드를 확인해 가면서 변경해야하기 때문에 굉장히 어려운 작업이 된다.
    - 개발 히스토리를 잘 알고 있는 사람이 아니라면 ***해당 코드를 수정하기 힘들 것이며 수정하더라도 어떤 여파가 일어날 지 알수가 없다.***
  - 또한 ***JPA에는 여러 자동화 기능을 제공하며 서비스 코드내에서 자동화 기능을 제어***해야한다.
    - 대표적으로 지연 로딩이 있으며 N + 1 문제를 생각해볼 수 있다.
  - ***저장소의 변경이 전역적으로 퍼져있는 모든 서비스 코드를 수정해야하는 경우가 발생***할 수 있다.
    - 예를 들어 RDS JPA를 사용하다 갑자기 메세지 큐, 파일, RDS <-> NoSQL과 같은 저장소로 변경이 되었을 때 변경에 대한 대응이 참으로 난감할 것이다.
    - 요즘 핫한 MSA를 생각해보면 모놀리식 아키텍쳐에서 MSA 아키텍쳐를 변경하는 작업에서 일부 저장소들이 계속해서 때어져 나가고 통신하는 방식으로 변경이 될 것인데 이 또한 저장소의 변경이기 때문에 해당 내용에 해당하는 모든 서비스 코드를 수정해야한다.

5. 모든 계층이 서로 접근이 가능하며 막을 방법이 없다.
  - 대부분의 개발자들은 Controller <-> Service <-> Persistence <-> Repository 형식으로 작업을 진행할 것이다.
  - 하지만 대부분의 개발이 클래스를 전부 public으로 열어놓고 작업을 진행할 것이다.
    - 제가 경험한 곳의 대부분이 이렇게 작업을 진행했기 때문에 개인적인 생각이므로 아닐수도 있다. 
    ```java
    @RestController
    public class MemberController {
    }

    @Service
    public class MemberServiceImpl implements MemberService {

    }

    @Repository
    public interface MemberJpaRepository extends JpaRepository<Member, Long> {
    }

    ```
  - 모든 계층 클래스 들이 public으로 열려 있으니 실제로 controller에서 repository를 불러올 수 도 있다는 의미이다.
    - 막말로 service가 controller를 불러올 수 도 있다.
    - 물론 문제가 발생하지 않을 수는 있지만 애초에 권장하지 않는 방식이다.
  - 클래스와 인터페이스는 default와 publice으로 밖에 접근 제어를 하지 못함으로 인해서 일반적인 계층형 아키텍처의 패키지 구조에서는 모든 계층을 public으로 열 수 밖에 없다.
  - ***우리가 원하는 계층으로 흘러가기를 원할 뿐이지 실제로 제어할 수는 없는 문제가 발생***한다. 




### 1. 매핑 전략

- 항상 논의가 되는 것은 각 계층별로 모델을 어떻게 매핑할 건지에 대한 논의가 끊이지 않는다.
- 매퍼 구현을 하기위한 논의 또는 매퍼 구현을 피하기 위한 논의를 해본적이 있을 것이다.
  - 매핑에 찬성하는 개발자
    - 매핑하지 않고 양 계층에서 같은 모델을 사용할 경우 두 계층이 강하게 결합됩니다.
    - 즉, 모델의 변경이 여러 계층에게 영향을 줄 수 있다는 의미이다.
  - 매핑에 반대하는 개발자
    - 두 계층간에 매핑을 하게 되면 변화없이 여러 군데에서 반복되는 코드 코드(보일러플레이트 코드)들이 많아진다.
    - 많은 유스케이스들은 오직 CRUD만 수행하고 계층에 걸쳐 같은 모델을 사용하기 때문에 계층 사이에 매핑은 과합니다.
  - 둘다 맞는말 아닌가?

#### 1.1. 매핑하지 않기 전략

- 모든 계층이 같은 모델을 사용하여 계층 간 매핑을 전혀 할 일이 없다.
  - 컨트롤러에서 유스케이스의 입력 모델
  - 유스케이스에서 리턴해주는 도메인
- 매핑하지 않기 전략에서의 도메인 모델 클래스의 역할
  - 웹 계층에서 REST로 모델을 리턴한다면 JSON으로 직렬화하기 위한 어노테이션 추가
  - ORM 프레임워크를 사용한다면 데이터베이스 매핑을 위한 특정 어노테이션 추가
  - 유스케이스 및 저장소 입력 모델에 대한 검증
- 도메인 모델 클래스가 모든 계층과 결합되어 있기 때문에 웹이나 영속성과 관련된 특수한 요구사항을 다뤄야한다.
- 매핑하지 않기 전략은 도메인이 단일 책임 원칙을 위반한다.
- 하지만 매핑하지 않기 전략이 딱 들어맞을 때가 있다.
- 간단한 CRUD 유스 케이스의 경우 같은 필드를 가진 웹 모델을 도메인 모델로, 혹은 도메인 모델을 영속성 모델로 매핑할 필요가 있을까?
- ***모든 계층이 정확히 같은 구조, 정확히 같은 정보를 필요로 한다면 '매핑하지 않기'전략은 완벽한 선택지***다.
- 그러나 ***애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제를 다루게 되면 곧바로 다른 전략을 취해아한다.***

#### 1.2. 양방향 매핑 전략





6. Domain(Business or Service) 계층 불러온 데이터를 통해서 Business 로직을 만든다.

- dao(jpa entity)



### 계층형 아키텍쳐


### 포트와 어댑터 패턴
- 포트와 어댑터 아키텍처를 적용하면 인터페이스나 기반 요소가
- 사용자의 요구 사항 혹은 수용 능력에 영향을 받아 변경된다고 하더라도 애플리케이션의 주요 동작(도메인 로직 혹은 비즈니스 로직)에는 아무런 영향을 주지 않습니다.
- 도메인 로직을 견고하게 유지하며 소프트웨어의 지속 가능성을 높일 수 있는 것이죠. 




- 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는다.
- 


### 유스 케이스 
---

- 유스 케이스라고 명칭하는 이유는 하나의 책임만을 가진 인터페이스를 사용해라는 의미가 아닐까 싶다.
#### 유스 케이스의 역할
1. 입력을 받는다.
2. 비지니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

- 유스케이스는 비지니스 규칙을 검증할 책임이 있다.

- 유즈 케이스는 입력 검증으로부터 오염되면 안된다.
  - 때문에 입력 검증은 입력 모델이 해당 책임을 가진다.
  - 자바에서 유효성 검증을 Bean Validation API가 해결해 줄 수 있다.
  - 입력 모델을 빌더 클래스를 통해서 만들면 새로운 필드를 추가했을 때 컴파일 에러가 발생하지 않는다.
    - 요즘은 IDE들이 파라미터명 힌트를 주기 때문에 생성자를 사용하는 것이 더 좋을 수 있다.
    - 또한 입력 모델의 경우에는 다른 경우에 사용되는 경우가 거의 없다
  - 입력 모델은 `입력모델명 + Command`라고 명명한다.
  - 다른 유스 케이스가 하나의 입력 모델을 공유하고 싶을 때가 있다.
    - 서로 다른 유효성 검증 로직이 필요함에도 불구하고 사용하는 필드가 비슷하다는 이유로 같은 클래스에서 사용할 경우 사이드 이펙트가 발생할 수 있다.
    - 뿐만 아니라 코드를 작성한 이후 다른 개발자가 보게 될 경우 해당 코드가 정확히 어떤 역할을 하는지 한번에 알아보기 힘들 수 있다.
    - 때문에 각 유스 케이스 별로 전용 입력 모델을 작성하는 것이 좋아 보인다.
    - 각 유스 케이스별로 전용 입력 모델을 작성하게 될 경우 입력 모델에 대한 역할을 명확하게 보여줄 수 있을 뿐더러, 다른 유스 케이스의 결합도 제거해서 불필요한 부수효과가 발생하지 않는다.
- 책임 검증 역할을 구분하면 테스트 코드 작성이 쉬워질 뿐더러 서비스 로직이 무엇을 하는지 다른 개발자가 봐도 명확해 진다.

> https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
> https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture
> https://jojoldu.tistory.com/603
